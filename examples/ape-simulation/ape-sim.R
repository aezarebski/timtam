#!/usr/bin/env Rscript
#'
#' ape-sim
#' =======
#'
#' Use the ape package from R to simulate the BDSCOD process.
#'
#' Usage
#' -----
#'
#' $ ./ape-sim.R -v -s 1 -p ../example-parameters.json -o out --duration 30.0
#'
suppressPackageStartupMessages(library("argparse"))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ggtree))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(treeio))
suppressPackageStartupMessages(library(tidytree))
suppressPackageStartupMessages(library(tibble))
suppressPackageStartupMessages(library(ape))

# create parser object
parser <- ArgumentParser()

parser$add_argument(
         "-v",
         "--verbose",
         action = "store_true",
         default = FALSE,
         help = "Verbose output"
       )
parser$add_argument(
         "-s",
         "--seed",
         type = "integer",
         default = 1,
         help = "PRNG seed"
       )
parser$add_argument(
         "-p",
         "--parameters",
         type = "character",
         help = "Filepath to parameters JSON"
       )
parser$add_argument(
         "-d",
         "--duration",
         type = "double",
         help = "Simulation duration"
       )
parser$add_argument(
         "-o",
         "--output-directory",
         type = "character",
         help = "Path to write output to"
       )
parser$add_argument(
         "--make-plots",
         action = "store_true",
         default = FALSE,
         help = "Generate plots"
       )


read_parameters <- function(parameter_filepath, sim_duration, is_verbose) {
  if (!file.exists(parameter_filepath)) {
    stop("Cannot find parameter file: ", parameter_filepath)
  } else if (sim_duration <= 0.0) {
    stop("Need a positive duration")
  } else {
    params <- jsonlite::read_json(parameter_filepath)
    ## it will be useful to have some other ways to talk about the parameters so
    ## we compute a couple of other views.
    params$net_rem_rate <-
      params$deathRate + params$samplingRate + params$occurrenceRate
    params$net_per_capita_event_rate <- params$birthRate + params$net_rem_rate
    params$sampling_prob <- params$samplingRate / params$net_rem_rate
    params$occurrence_prob <- params$occurrenceRate / params$net_rem_rate
    params$prob_observed <- params$sampling_prob + params$occurrence_prob
    params$prob_sampled_given_observed <-
      params$sampling_prob / params$prob_observed
    params$duration = sim_duration
    return(params)
  }
}

run_simulation <- function(params, is_verbose) {
  time_eps <- 1e-6
  if (is_verbose) {
    cat("simulating tmrca and phylogeny...\n")
  }
  ## because the trees generated by rlineage start from the TMRCA we need to
  ## simulate the length of the root first and subtract this from the duration.
  tmrca <- rexp(n = 1, rate = params$net_per_capita_event_rate)
  phy <- rlineage(
    params$birthRate,
    params$net_rem_rate,
    Tmax = params$duration - tmrca,
    eps = time_eps
  )
  if (is_verbose) {
    cat("extracting tip times and labels...\n")
  }
  ## because we are going to be subsampling the tips it is useful to have some
  ## easier ways to refer to them.
  tip_labels <- phy$tip.label
  num_tips <- length(tip_labels)
  tip_ix <- seq.int(num_tips)
  tip_times <- head(node.depth.edgelength(phy), num_tips)
  ## TODO we can find the tips that are still extant in the simulation but it is
  ## unclear if we can use strict equality here of if we need to account for
  ## potential error in the branch lengths.
  extant_mask <- tip_times + tmrca == params$duration
  extant_labels <- tip_labels[extant_mask]
  extinct_labels <- tip_labels[!extant_mask]
  num_extinct <- length(extinct_labels)
  ## We can select which extinctions are deaths, samples and occurrences by
  ## binomially sampling with the correct probabilities.
  num_observed <- rbinom(
    n = 1,
    size = num_extinct,
    prob = params$prob_observed
  )
  num_sampled <- rbinom(
    n = 1,
    size = num_observed,
    prob = params$prob_sampled_given_observed
  )

  observed_labels <- sample(
    x = extinct_labels,
    size = num_observed,
    replace = FALSE
  )
  sampling_labels <- sample(
    x = observed_labels,
    size = num_sampled,
    replace = FALSE
  )

  occurrence_labels <- setdiff(observed_labels, sampling_labels)
  num_occurrences <- length(occurrence_labels)
  unobserved_labels <- setdiff(extinct_labels, observed_labels)

  ## It is useful to have a vector describing what happened to each of the tips
  ## so we will generate this.
  outcome <- character(num_tips)
  for (ix in tip_ix) {
    tl <- tip_labels[ix]
    outcome[ix] <-
      if (is.element(tl, extant_labels)) {
        "extant"
      } else if (is.element(tl, unobserved_labels)) {
        "death"
      } else if  (is.element(tl, sampling_labels)) {
        "sampling"
      } else if (is.element(tl, occurrence_labels)) {
        "occurrence"
      } else {
        stop("unaccounted for tip: ", tl)
      }
  }

  is_observed <- is.element(outcome, c("sampling", "occurrence"))
  ## We then drop the lineages that did not result in a sampled lineage to get
  ## the reconstructed tree.
  rt <- keep.tip(phy, sampling_labels)
  rt_tip_and_node_depths <- node.depth.edgelength(rt)
  rt_tip_depths <- head(rt_tip_and_node_depths, num_sampled)
  rt_node_depths <- tail(rt_tip_and_node_depths, -num_sampled)
  ## The depths of the nodes and tips is relative to the TMRCA so we need to
  ## adjust for this when computing the extact times that they occurred at.
  true_first_sample_time <- min(tip_times[outcome == "sampling"])
  depth_first_in_rt <- min(rt_tip_depths)
  rt_offset <- true_first_sample_time - depth_first_in_rt
  ## Finally we can put all of this information into a single dataframe.
  event_times_df <- data.frame(
    time = c(-tmrca, tip_times[outcome == "occurrence"], tip_times[outcome == "sampling"], rt_node_depths + rt_offset),
    event = c("origin", rep(c("occurrence", "sampling", "birth"), times = c(num_occurrences, num_sampled, num_sampled - 1)))
  )
  if (is_verbose) {
    cat("checking output from run_simulation...\n")
  }
  ## We can do a quick check of the results to make sure that some invariants
  ## have been preserved. Note that one of the checks here will fail a small
  ## percent of the time because it is not exact.
  dur_1 <- max(tip_times[outcome == "sampling"]) + tmrca
  dur_2 <- max(rt_tip_depths) + rt_offset + tmrca
  ## these should be equal up to numerical error.
  stopifnot(abs(dur_1 - dur_2) < 1e-10 * params$duration)
  dur_3 <- max(tip_times[outcome == "extant"]) + tmrca
  stopifnot(abs(dur_3 - params$duration) < time_eps)
  return(list(event_times_df = event_times_df))
}

write_plot <- function(simulation_results, output_directory, is_verbose) {
  stop("not implemented.")
}

main <- function(args) {
  if (args$verbose) {
    cat("Reading parameters from", args$parameters, "\n")
  }

  set.seed(args$seed)

  params <- read_parameters(args$parameters, args$duration, args$verbose)

  sim_result <- run_simulation(params, args$verbose)

  if (file.access(args$output_directory, mode = 2) != 0) {
    stop("Cannot write to output directory: ", args$output_directory)
  } else {
    output_csv <- paste(
      args$output_directory,
      "ape-sim-event-times.csv",
      sep = "/"
    )
    write.table(x = sim_result$event_times_df,
                file = output_csv,
                sep = ",",
                row.names = FALSE)
  }

  if (args$make_plots) {
    write_plot(sim_result, args$output_directory, args$verbose)
  }
}

if (!interactive()) {
  args <- parser$parse_args()
  main(args)
} else {
  args <- list(
    verbose = TRUE,
    seed = 1,
    parameters = "../example-parameters.json",
    duration = 30.0,
    output_directory = "out",
    make_plots = TRUE
  )
  main(args)
}



