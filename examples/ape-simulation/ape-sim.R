#!/usr/bin/env Rscript
#'
#' ape-sim
#' =======
#'
#' Use the ape package from R to simulate the BDSCOD process. When run in
#' interactive mode this will substitute some parameters otherwise it expected
#' to get everything from the command line.
#'
#' By default this avoids a population sample at the end of the simulation but
#' there is a command line argument if you want to include this.
#'
#' Usage
#' -----
#'
#' $ ./ape-sim.R --seed 1 -p ../example-parameters.json -o out --duration 30.0
#'
#' or if you want to generate a figure showing the simulated data append the
#' --make-plots flag.
#'
#' Help
#' ----
#'
#' $ ./ape-sim.R --help
#'
suppressPackageStartupMessages(library("argparse"))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ggtree))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(treeio))
suppressPackageStartupMessages(library(tidytree))
suppressPackageStartupMessages(library(tibble))
suppressPackageStartupMessages(library(ape))

# create parser object
parser <- ArgumentParser()

parser$add_argument(
         "-v",
         "--verbose",
         action = "store_true",
         default = FALSE,
         help = "Verbose output"
       )
parser$add_argument(
         "-s",
         "--seed",
         type = "integer",
         default = 1,
         help = "PRNG seed"
       )
parser$add_argument(
         "-p",
         "--parameters",
         type = "character",
         help = "Filepath to parameters JSON"
       )
parser$add_argument(
         "-d",
         "--duration",
         type = "double",
         help = "Simulation duration"
       )
parser$add_argument(
         "-o",
         "--output-directory",
         type = "character",
         help = "Path to write output to"
       )
parser$add_argument(
         "--make-plots",
         action = "store_true",
         default = FALSE,
         help = "Generate plots"
       )
parser$add_argument(
         "-r",
         "--rho",
         type = "double",
         default = -1.0,
         help = "Scheduled sample probability")

read_parameters <- function(parameter_filepath, sim_duration, maybe_rho, is_verbose) {
  if (!file.exists(parameter_filepath)) {
    stop("Cannot find parameter file: ", parameter_filepath)
  } else if (sim_duration <= 0.0) {
    stop("Need a positive duration")
  } else if (!(is.null(maybe_rho) | is.numeric(maybe_rho))) {
    stop("Need a maybe numeric value for maybe_rho")
  } else {
    params <- jsonlite::read_json(parameter_filepath)
    expected_names <-
      c("birthRate",
        "deathRate",
        "samplingRate",
        "occurrenceRate")
    stopifnot(setequal(names(params), expected_names))
    ## it will be useful to have some other ways to talk about the parameters so
    ## we compute a couple of other views.
    params$net_rem_rate <-
      params$deathRate + params$samplingRate + params$occurrenceRate
    params$net_per_capita_event_rate <- params$birthRate + params$net_rem_rate
    params$sampling_prob <- params$samplingRate / params$net_rem_rate
    params$occurrence_prob <- params$occurrenceRate / params$net_rem_rate
    params$prob_observed <- params$sampling_prob + params$occurrence_prob
    params$prob_sampled_given_observed <-
      params$sampling_prob / params$prob_observed
    params$duration <- sim_duration
    ## we need to handle the possibility that there is a valid rho.
    if (is.null(maybe_rho)) {
      params$rho <- maybe_rho
      return(params)
    } else {
      if (0 < maybe_rho && maybe_rho < 1) {
        params$rho <- maybe_rho
        return(params)
      } else {
        stop("invalid rho argument: ", maybe_rho)
      }
    }
  }
}

run_simulation <- function(params, is_verbose) {
  time_eps <- 1e-6
  if (is_verbose) {
    cat("simulating tmrca and phylogeny...\n")
  }
  ## because the trees generated by rlineage start from the TMRCA we need to
  ## simulate the length of the root first and subtract this from the duration.
  tmrca <- rexp(n = 1, rate = params$net_per_capita_event_rate)
  phy <- rlineage(
    params$birthRate,
    params$net_rem_rate,
    Tmax = params$duration - tmrca,
    eps = time_eps
  )
  if (is_verbose) {
    cat("extracting tip times and labels...\n")
  }
  ## because we are going to be subsampling the tips it is useful to have some
  ## easier ways to refer to them.
  tip_labels <- phy$tip.label
  num_tips <- length(tip_labels)
  tip_ix <- seq.int(num_tips)
  tip_times <- head(ape::node.depth.edgelength(phy), num_tips)
  ## TODO we can find the tips that are still extant in the simulation but it is
  ## unclear if we can use strict equality here of if we need to account for
  ## potential error in the branch lengths. It seems like this is safe...
  extant_mask <- tip_times + tmrca == params$duration
  extant_labels <- tip_labels[extant_mask]
  num_extant <- length(extant_labels)
  ## We need to do a rho sample at the end of the duration if one has been
  ## requested, otherwise we need to propagate the null values.
  if (is.null(params$rho)) {
    num_rho_sampled <- NULL
    rho_sampled_labels <- NULL
  } else {
    num_rho_sampled <- rbinom(
      n = 1,
      size = num_extant,
      prob = params$rho
    )
    rho_sampled_labels <- sample(
      x = extant_labels,
      size = num_rho_sampled,
      replace = FALSE
    )
  }
  extinct_labels <- tip_labels[!extant_mask]
  num_extinct <- length(extinct_labels)
  ## We can select which extinctions are deaths, samples and occurrences by
  ## binomially sampling with the correct probabilities.
  num_observed <- rbinom(
    n = 1,
    size = num_extinct,
    prob = params$prob_observed
  )
  num_sampled <- rbinom(
    n = 1,
    size = num_observed,
    prob = params$prob_sampled_given_observed
  )

  observed_labels <- sample(
    x = extinct_labels,
    size = num_observed,
    replace = FALSE
  )
  sampling_labels <- sample(
    x = observed_labels,
    size = num_sampled,
    replace = FALSE
  )

  occurrence_labels <- setdiff(observed_labels, sampling_labels)
  num_occurrences <- length(occurrence_labels)
  unobserved_labels <- setdiff(extinct_labels, observed_labels)

  ## It is useful to have a vector describing what happened to each of the tips
  ## so we will generate this.
  outcome <- character(num_tips)
  for (ix in tip_ix) {
    tl <- tip_labels[ix]
    outcome[ix] <-
      if (is.element(tl, extant_labels)) {
        if (is.null(rho_sampled_labels)) {
          "extant"
        } else if (is.element(tl, rho_sampled_labels)) {
          "rho"
        } else {
          "extant"
        }
      } else if (is.element(tl, unobserved_labels)) {
        "death"
      } else if  (is.element(tl, sampling_labels)) {
        "sampling"
      } else if (is.element(tl, occurrence_labels)) {
        "occurrence"
      } else {
        stop("unaccounted for tip: ", tl)
      }
  }
  ## We then drop the lineages that did not result in a sampled lineage to get
  ## the reconstructed tree.
  rt_tip_labels <- c(sampling_labels, rho_sampled_labels)
  num_rt_tips <- length(rt_tip_labels)
  rt <- ape::keep.tip(phy, rt_tip_labels)
  rt_tip_and_node_depths <- ape::node.depth.edgelength(rt)
  rt_tip_depths <- head(rt_tip_and_node_depths, num_rt_tips)
  rt_node_depths <- tail(rt_tip_and_node_depths, -num_rt_tips)
  ## The depths of the nodes and tips is relative to the TMRCA so we need to
  ## adjust for this when computing the extact times that they occurred at.
  true_first_sample_time <-
    min(tip_times[outcome == "sampling" | outcome == "rho"])
  depth_first_in_rt <- min(rt_tip_depths)
  rt_offset <- true_first_sample_time - depth_first_in_rt
  ## Finally we can put all of this information into a single dataframe.
  event_times_df <- data.frame(
    time = c(-tmrca,
             tip_times[outcome == "occurrence"],
             tip_times[outcome == "sampling"],
             tip_times[outcome == "rho"],
             rt_node_depths + rt_offset
             ),
    event = c("origin",
              rep(
                c("occurrence", "sampling", "rho", "birth"),
                times = c(num_occurrences,
                          num_sampled,
                          ifelse(is.null(num_rho_sampled), 0, num_rho_sampled),
                          ifelse(is.null(num_rho_sampled), num_sampled - 1, num_rt_tips - 1))
              )
              )
  )
  if (is_verbose) {
    cat("checking output from run_simulation...\n")
  }
  ## We can do a quick check of the results to make sure that some invariants
  ## have been preserved. Note that one of the checks here will fail a small
  ## percent of the time because it is not exact.
  dur_1 <- max(tip_times[outcome == "sampling" | outcome == "rho"]) + tmrca
  dur_2 <- max(rt_tip_depths) + rt_offset + tmrca
  ## these should be equal up to numerical error.
  stopifnot(abs(dur_1 - dur_2) < 1e-10 * params$duration)
  dur_3 <- max(tip_times[outcome == "extant"]) + tmrca
  stopifnot(abs(dur_3 - params$duration) < time_eps)
  return(list(
    event_times_df = event_times_df,
    phylo = phy,
    outcome = outcome,
    tip_ix = tip_ix,
    num_extinct = num_extinct,
    num_extant = num_extant,
    num_sampled = num_sampled,
    num_rho_sampled = num_rho_sampled,
    num_observed = num_observed,
    num_occurrences = num_occurrences))
}

write_plot <- function(simulation_results, parameters, output_directory, is_verbose) {
  hist_plt_df <- data.frame(
    outcome = c("death",
                "sampling",
                "occurrence"),
    empirical = c(simulation_results$num_extinct - simulation_results$num_observed,
                  simulation_results$num_sampled,
                  simulation_results$num_occurrences),
    theory = c(qbinom(p = 0.5,
                      size = simulation_results$num_extinct,
                      prob = 1 - parameters$sampling_prob - parameters$occurrence_prob),
               qbinom(p = 0.5,
                      size = simulation_results$num_extinct,
                      prob = parameters$sampling_prob),
               qbinom(p = 0.5,
                      size = simulation_results$num_extinct,
                      prob = parameters$occurrence_prob)),
    theory_min = c(qbinom(p = 0.025,
                          size = simulation_results$num_extinct,
                          prob = 1 - parameters$sampling_prob - parameters$occurrence_prob),
                   qbinom(p = 0.025,
                          size = simulation_results$num_extinct,
                          prob = parameters$sampling_prob),
                   qbinom(p = 0.025,
                          size = simulation_results$num_extinct,
                          prob = parameters$occurrence_prob)),
    theory_max = c(qbinom(p = 0.975,
                          size = simulation_results$num_extinct,
                          prob = 1 - parameters$sampling_prob - parameters$occurrence_prob),
                   qbinom(p = 0.975,
                          size = simulation_results$num_extinct,
                          prob = parameters$sampling_prob),
                   qbinom(p = 0.975,
                          size = simulation_results$num_extinct,
                          prob = parameters$occurrence_prob))
  )

  if (!is.null(parameters$rho)) {
    rho_row <- data.frame(
      outcome = "rho",
      empirical = simulation_results$num_rho_sampled,
      theory = qbinom(p = 0.5,
                      size = simulation_results$num_extant,
                      prob = parameters$rho),
      theory_min = qbinom(p = 0.025,
                          size = simulation_results$num_extant,
                          prob = parameters$rho),
      theory_max = qbinom(p = 0.975,
                          size = simulation_results$num_extant,
                          prob = parameters$rho)
    )
    hist_plt_df <- rbind(hist_plt_df, rho_row)
  }

  plt5 <- ggplot(hist_plt_df) +
    geom_col(mapping = aes(x = outcome, y = empirical)) +
    geom_point(mapping = aes(x = outcome, y = theory)) +
    geom_errorbar(mapping = aes(x = outcome, ymin = theory_min, ymax = theory_max)) +
    labs(y = "Count", x = NULL) +
    theme_classic()

  is_observed <- is.element(simulation_results$outcome, c("sampling", "occurrence", "rho"))

  tip_annotations <- tibble(
    node = simulation_results$tip_ix,
    outcome = simulation_results$outcome,
    is_observed = is_observed
  )

  ## TODO does this come from tidytree???
  tr <- treedata(phylo = simulation_results$phylo, data = tip_annotations)

  plt4 <- ggplot(tr, mapping = aes(x, y)) +
    geom_tippoint(mapping = aes(colour = outcome, shape = is_observed),
                  size = 3) +
    geom_nodepoint() +
    geom_vline(data = simulation_results$event_times_df, aes(xintercept = time, colour = event)) +
    geom_tree() +
    labs(colour = "Tip outcome",
         shape = "Observed") +
    theme_tree2(legend.position = "top")

  if (is_verbose) {
    cat("writing visualistion to file...\n")
  }
  ggsave(
    filename = paste(
      output_directory,
      "ape-simulation-figure.png",
      sep = "/"
    ),
    plot = plot_grid(plt4, plt5, nrow = 1, rel_widths = c(2, 1)),
    width = 25,
    height = 15,
    units = "cm"
  )
}

main <- function(args) {
  if (args$verbose) {
    cat("reading parameters from", args$parameters, "\n")
  }

  set.seed(args$seed)

  ## Awkward because you cannot assign NULL via ifelse.
  if (args$rho == -1.0) {
    maybe_rho <-  NULL
  } else {
    maybe_rho <-  args$rho
  }

  if (args$verbose) {
    if (is.null(maybe_rho)) {
      cat("without rho sampling at the end of the simulation\n")
    } else {
      cat("with rho sampling at the end of the simulation\n")
    }
  }
  params <- read_parameters(
    args$parameters,
    args$duration,
    maybe_rho,
    args$verbose)

  sim_result <- run_simulation(params, args$verbose)

  if (file.access(args$output_directory, mode = 2) != 0) {
    stop("Cannot write to output directory: ", args$output_directory)
  } else {
    output_csv <- paste(
      args$output_directory,
      "ape-sim-event-times.csv",
      sep = "/"
    )
    if (args$verbose) {
      cat("writing output to csv...\n")
    }
    write.table(x = sim_result$event_times_df,
                file = output_csv,
                sep = ",",
                row.names = FALSE)
  }

  if (args$make_plots) {
    write_plot(sim_result, params, args$output_directory, args$verbose)
  }
}

if (!interactive()) {
  args <- parser$parse_args()
  main(args)
} else {
  args <- list(
    verbose = TRUE,
    seed = 1,
    parameters = "../example-parameters.json",
    duration = 30.0,
    output_directory = "out",
    make_plots = TRUE,
    rho = 0.1
  )
  main(args)
}
