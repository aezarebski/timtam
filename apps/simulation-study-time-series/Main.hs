{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE RecordWildCards #-}

module Main where

import BDSCOD.Conditioning
import BDSCOD.Llhd
import BDSCOD.Types
import BDSCOD.Utility
import Control.Monad.Except (ExceptT, runExceptT, throwError)
import Control.Monad.Reader (ReaderT, asks, liftIO, runReaderT)
import qualified Data.Aeson as Json
import qualified Epidemic.Utility as SimUtil
import qualified Data.ByteString.Lazy as L
import qualified Epidemic.BDSCOD as SimBDSCOD
import Epidemic.Types.Parameter
import qualified Data.ByteString.Lazy as L
import qualified Data.ByteString.Builder as BBuilder
import qualified Data.Csv as Csv
import Data.List (intercalate, intersperse)
import Data.Maybe (fromJust)
import Epidemic.Types.Events (maybeEpidemicTree,asNewickString,maybeReconstructedTree)
import GHC.Generics
import Epidemic.Types.Population (Person(..))
import System.Environment (getArgs)
-- import BDSCOD.Conditioning
-- import BDSCOD.Llhd
-- import BDSCOD.Types
-- import BDSCOD.Utility
-- import qualified Data.Aeson as Json
-- import qualified Data.ByteString.Builder as BBuilder
-- import Data.Map.Strict (Map(),fromList,toList)
-- import Epidemic.Types.Events
-- import Epidemic.Types.Parameter
-- import GHC.Generics
-- import System.Environment (getArgs)


data Configuration =
  Configuration
    { simulatedEventsOutputCsv :: FilePath
    , simulationParameters :: Parameters
    , simulationDuration :: Time
    , reconstructedTreeOutputFiles :: (FilePath,FilePath)
    , observationsOutputCsv :: FilePath
    , evaluationParameters :: [Parameters]
    , llhdOutputCsv :: FilePath
    }
  deriving (Show, Generic)

instance Json.FromJSON Configuration

type Simulation x = ReaderT Configuration (ExceptT String IO) x

-- A BDSCOD simulation configuration based on the parameters in the environment.
bdscodConfiguration = do
  simParams <- asks simulationParameters
  simDur <- asks simulationDuration
  let bdscodConfig = SimBDSCOD.configuration simDur simParams
  case bdscodConfig of
    Nothing -> throwError "Could not construct BDSCOD configuration"
    (Just config) -> return config

-- Run the actual simulation and record the results before returning the dataset
-- of observations generated by this epidemic.
simulatedObservations bdscodConfig = do
  -- simulate the epidemic without conditioning because the conditioning code
  -- assumes there will be psi-samples.
  simEvents <- liftIO $ SimUtil.simulationWithSystemRandom False bdscodConfig SimBDSCOD.allEvents
  simEventsCsv <- asks simulatedEventsOutputCsv
  liftIO $ L.writeFile simEventsCsv (Csv.encode simEvents)
  let Just (newickBuilder,newickMetaData) = asNewickString (0, Person 1) =<< maybeReconstructedTree =<< maybeEpidemicTree simEvents
      maybeObs = eventsAsObservations <$> SimBDSCOD.observedEvents simEvents
  case maybeObs of
    (Just obs) -> do (reconNewickTxt,reconNewickCsv) <- asks reconstructedTreeOutputFiles
                     liftIO $ L.writeFile reconNewickTxt (BBuilder.toLazyByteString newickBuilder)
                     liftIO $ L.writeFile reconNewickCsv (Csv.encode newickMetaData)
                     obsCsv <- asks observationsOutputCsv
                     liftIO $ L.writeFile obsCsv (Csv.encode obs)
                     return obs
    Nothing -> throwError "Failed to simulate observations."



-- Run the evaluation of the log-likelihood profiles on a given set of
-- observations and write the result to file.
evaluateLLHD :: [Observation] -> Simulation ()
evaluateLLHD obs = do
  llhdsCsv <- asks llhdOutputCsv
  evalParams <- asks evaluationParameters
  let comma = BBuilder.charUtf8 ','
      llhdVals = [fst $ llhdAndNB obs p initLlhdState | p <- evalParams] :: [LogLikelihood]
      doublesAsString = BBuilder.toLazyByteString . mconcat . intersperse comma . map BBuilder.doubleDec
  liftIO $ L.writeFile llhdsCsv (doublesAsString llhdVals)

-- | Record the partial results of the LLHD and NB to a CSV at the parameters
-- used in the simulation.
partialEvaluations :: [Observation] -> Simulation ()
partialEvaluations obs = do
  simParams <- asks simulationParameters
  let partialResults = snd $ verboseLlhdAndNB obs simParams initLlhdState
      records = [show l ++ "," ++ show nb | (l,nb) <- partialResults]
      partialEvalsCsv = "out/partial-evaluations.csv"
  liftIO $ Prelude.writeFile partialEvalsCsv (intercalate "\n" records)

-- Definition of the simulation study.
simulationStudy :: Simulation ()
simulationStudy = do
  bdscodConfig <- bdscodConfiguration
  obs <- simulatedObservations bdscodConfig
  evaluateLLHD obs
  partialEvaluations obs
  return ()

main :: IO ()
main = do
  configFilePath <- head <$> getArgs
  maybeConfig <- getConfiguration configFilePath
  case maybeConfig of
    Nothing ->
      putStrLn $ "Could not get configuration from file: " ++ configFilePath
    Just config -> do
      result <- runExceptT (runReaderT simulationStudy config)
      case result of
        Left errMsg -> putStrLn errMsg
        Right _ -> return ()

getConfiguration :: FilePath -> IO (Maybe Configuration)
getConfiguration fp = Json.decode <$> L.readFile fp
